//
//  VimeoClient.swift
//  VimeoNetworkingExample-iOS
//
//  Created by Huebner, Rob on 3/21/16.
//  Copyright Â© 2016 Vimeo. All rights reserved.
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
//

import Foundation

/// `VimeoClient` handles a rich assortment of functionality focused around interacting with the Vimeo API.  A client object tracks an authenticated account, handles the low-level execution of requests through a session manager with caching functionality, presents a high-level `Request` and `Response` interface, and notifies of globally relevant events and errors through `Notification`s
/// To start using a client, first instantiate an `AuthenticationController` to load a stored account or authenticate a new one.  Next, create `Request` instances and pass them into the `request` function, which returns `Response`s on success.
final public class VimeoClient {
    // MARK: -
    
    /// `RequestToken` stores a reference to an in-flight request
    public struct RequestToken {

        /// The path of the request
        public let path: String?
        
        /// The data task of the request
        public let task: Task?

        /// Resumes the request token task
        public func resume() {
            self.task?.resume()
        }

        /// Cancels the request token task
        public func cancel() {
            self.task?.cancel()
        }
    }
    
    /// Dictionary containing URL parameters for a request
    public typealias RequestParametersDictionary = [String: Any]
    
    /// Array containing URL parameters for a request
    public typealias RequestParametersArray = [Any]
    
    /// Dictionary containing a JSON response
    public typealias ResponseDictionary = [String: Any]
    
    /// Domain for errors generated by `VimeoClient`
    public static let ErrorDomain = "VimeoClientErrorDomain"
    
    // MARK: -
    
    /// Session manager handles the http session data tasks and request/response serialization
    internal var sessionManager: SessionManaging? = nil
    
    /// response cache handles all memory and disk caching of response dictionaries
    internal let responseCache = ResponseCache()

    private var reachabilityManager: ReachabilityManaging?

    /// Create a new client
    ///
    /// - Parameters:
    ///   - appConfiguration: Your application's configuration
    ///   - configureSessionManagerBlock: a block to configure the session manager
    convenience public init(
        appConfiguration: AppConfiguration,
        reachabilityManager: ReachabilityManaging? = nil,
        configureSessionManagerBlock: ConfigureSessionManagerBlock? = nil
    ) {
        let reachabilityManager = reachabilityManager ?? VimeoReachabilityProvider.reachabilityManager
        let sessionManager = VimeoSessionManager.defaultSessionManager(
            appConfiguration: appConfiguration,
            configureSessionManagerBlock: configureSessionManagerBlock
        )
        self.init(
            appConfiguration: appConfiguration,
            reachabilityManager: reachabilityManager,
            sessionManager: sessionManager
        )
    }
    
    public init(
        appConfiguration: AppConfiguration? = nil,
        reachabilityManager: ReachabilityManaging? = nil,
        sessionManager: SessionManaging? = nil
    ) {
        let reachabilityManager = reachabilityManager ?? VimeoReachabilityProvider.reachabilityManager
        self.reachabilityManager = reachabilityManager
        if let appConfiguration = appConfiguration,
            let sessionManager = sessionManager {
            self.configuration = appConfiguration
            self.sessionManager = sessionManager
        }
    }
    
    // MARK: - Configuration
    
    /// The client's configuration
    public fileprivate(set) var configuration: AppConfiguration? = nil
    
    // MARK: - Authentication
    
    /// Stores the current account, if one exists
    public internal(set) var currentAccount: Account? {
        didSet {
            if let authenticatedAccount = self.currentAccount {
                self.sessionManager?.clientDidAuthenticate(with: authenticatedAccount)
            }
            else {
                self.sessionManager?.clientDidClearAccount()
            }
            
            self.notifyObserversAccountChanged(forAccount: self.currentAccount, previousAccount: oldValue)
        }
    }
    
    internal func notifyObserversAccountChanged(forAccount account: Account?, previousAccount: Account?) {
        NetworkingNotification.authenticatedAccountDidChange.post(object: account,
                                                        userInfo: [UserInfoKey.previousAccount.rawValue as String : previousAccount ?? NSNull()])
    }
}

// MARK: - Client configuration utility

extension VimeoClient {

    /// Configures a client instance and its associated session manager with the given configuration,
    /// reachability manager and an optional configuration block.
    /// - Parameter client: the `VimeoClient` instance to be configured
    /// - Parameter appConfiguration: the `AppConfiguration` object to be used by the client and associated session manager
    /// - Parameter reachabilityManager: the `ReachabilityManaging` instance to be used by the client and associated
    /// session to determine network reachability status. If none is provided the default reachability manager is used
    /// - Parameter configureSessionManagerBlock: An optional configuration block for the client's session manager
    ///
    /// Note that calling this method invalidates the `VimeoClient`'s existing session manager and creates
    /// a new instance with the given configuration.
    public static func configure(
        _ client: VimeoClient,
        appConfiguration: AppConfiguration,
        reachabilityManager: ReachabilityManaging? = nil,
        configureSessionManagerBlock: ConfigureSessionManagerBlock? = nil
    ) {
        let reachabilityManager = reachabilityManager ?? VimeoReachabilityProvider.reachabilityManager
        client.configuration = appConfiguration
        let defaultSessionManager = VimeoSessionManager.defaultSessionManager(
            appConfiguration: appConfiguration,
            configureSessionManagerBlock: configureSessionManagerBlock
        )
        client.sessionManager?.invalidate(cancelingPendingTasks: false)
        client.sessionManager = defaultSessionManager
        client.reachabilityManager = reachabilityManager
    }
}

// MARK: - Request
extension VimeoClient {
    /// Executes a `Request` encapsulated into an `EndpointType` and bound to a `Decodable` response.
    ///
    /// - Parameters:
    ///   - endpoint: `EndpointType` object containing the information required to build a request
    ///   - startImmediately: a boolean indicating whether or not the request should resume immediately
    ///   - completionQueue: dispatch queue on which to execute the callback closure
    ///   - callback: a closure executed once the request completes, containing a `Result` type
    ///   for the specified decodable.
    ///
    /// - Returns: a `RequestToken` for the in-flight request
    public func request<Model: Decodable>(
        _ endpoint: EndpointType,
        startImmediately: Bool = true,
        completionQueue: DispatchQueue = .main,
        then callback: @escaping (Result<Model, Error>) -> Void
    ) -> RequestToken {
        let task = self.sessionManager?.request(
            endpoint,
            parameters: nil,
            then: { (sessionManagingResult: SessionManagingResult<Model>) in
                completionQueue.async {
                    callback(sessionManagingResult.result)
                }
            }
        )
        if startImmediately { task?.resume() }
        return RequestToken(path: endpoint.path, task: task)
    }
}
